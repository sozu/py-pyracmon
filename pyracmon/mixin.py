from functools import reduce
from .model import *
from .select import *
from .query import *
from .util import key_to_index


class CRUDMixin(SelectMixin):
    """
    This class provides class methods available on all model classes.

    Every method takes the DB connection object as its first argument.

    Also, arguments listed below are commonly used in some methods of this mixin class:

    - `pks` represents value(s) of primary key(s).
        - If `pks` is a dictionary, each item is considered to be a pair of column name and value for primary keys respectively.
        - Otherwise, the model must have a primary key and `pks` is considered as its value.
    - `gen_condition` represents a condition or a function generating a condition with marker object.
        - This polymorphism enables the use of marker especially if it is stateful.
    - `qualifier` is a dictionary whose key is a column name and the value is a function generating SQL expression around the placeholder for the column.
        - By default in insert and update query, the expressions generated by a marker is used for column values.
        - This argument is used to override the expression.
        - Because the function takes default expression as an argument, you can generate another expression by qualifying it.
    """
    @classmethod
    def count(cls, db, condition=Q.of()):
        """
        Count rows which satisfies the condition.

        Parameters
        ----------
        db: Connection
            DB connection.
        condition: Conditional
            Conditional object.

        Returns
        -------
        int
            The number of rows.
        """
        wc, wp = where(condition)
        c = db.stmt().execute(f"SELECT COUNT(*) FROM {cls.name}{_spacer(wc)}", *wp)
        return c.fetchone()[0]

    @classmethod
    def fetch(cls, db, pks, lock=None):
        """
        Fetch a record by primary key(s).

        Parameters
        ----------
        db: Connection
            DB connection.
        pks: object | {str: object}
            A primary key or a mapping from column name to a value of primary keys.
        lock: object
            An object whose string representation is a valid locking statement.

        Returns
        -------
        cls
            A model of the record.
        """
        cols, vals = parse_pks(cls, pks)
        cond = Conditional.all([Q.eq(**{c: v}) for c, v in zip(cols, vals)])
        wc, wp = where(cond)
        s = cls.select()
        c = db.stmt().execute(f"SELECT {s} FROM {cls.name}{_spacer(wc)}{_spacer(lock)}", *wp)
        row = c.fetchone()
        return read_row(row, s)[0] if row else None

    @classmethod
    def fetch_where(cls, db, condition=Q.of(), orders={}, limit=None, offset=None, lock=None):
        """
        Fetch records which fulfill a condition.

        Parameters
        ----------
        db: Connection
            DB connection.
        gen_condition: Q.C | Marker -> Q.C
            Condition or a function creating a condition with a marker.
        orders: {str: bool}
            Ordered dict composed of column names and their ordering method. `True` means `ASC` and `False` means `DESC`.
        limit: int
            The number of rows to fetch. If `None`, all rows are obtained.
        offset: int
            The number of rows to skip.
        lock: object
            An object whose string representation is a valid locking statement.

        Returns
        -------
        [cls]
            Models of records.
        """
        wc, wp = where(condition)
        rc, rp = ranged_by(limit, offset)
        s = cls.select()
        c = db.stmt().execute(f"SELECT {s} FROM {cls.name}{_spacer(wc)}{_spacer(order_by(orders))}{_spacer(rc)}{_spacer(lock)}", *(wp + rp))
        return [read_row(row, s)[0] for row in c.fetchall()]

    @classmethod
    def insert(cls, db, record, qualifier={}):
        """
        Insert a record.

        Returned model object contains auto incremental column even if they are not set beforehand.
        However, be aware that it does not always have actual column values when qualifier is given.

        Parameters
        ----------
        db: Connection
            DB connection.
        record: {str: object} | model
            Columns and values to insert.
        qualifier: {str: str -> str}
            A mapping from column name to a function converting holder marker into another SQL expression.

        Returns
        -------
        Model
            Model object.
        """
        record = record if isinstance(record, cls) else cls(**record)
        value_dict = model_values(cls, record)
        check_columns(cls, value_dict)
        cols, vals = list(value_dict.keys()), list(value_dict.values())
        qualifier = key_to_index(qualifier, cols)

        db.stmt().execute(f"INSERT INTO {cls.name} ({', '.join(cols)}) VALUES {values(len(cols), 1, qualifier)}", *vals)

        for c, v in cls.last_sequences(db, 1):
            setattr(record, c.name, v)

        return record

    @classmethod
    def update(cls, db, pks, values, qualifier={}):
        """
        Update a record by primary key(s).

        Parameters
        ----------
        db: Connection
            DB connection.
        pks: object | {str: object}
            A primary key or a mapping from column name to a value of primary keys.
        values: {str: object} | model
            Columns and values to update.
        qualifier: {str: str -> str}
            A mapping from column name to a function converting holder marker into another SQL expression.

        Returns
        -------
        object
            An object returned by `execute()` of DB-API 2.0 module.
        """
        cols, vals = parse_pks(cls, pks)
        return cls.update_where(db, values, Conditional.all([Q.eq(**{c: v}) for c, v in zip(cols, vals)]), qualifier) == 1

    @classmethod
    def update_where(cls, db, values, condition, qualifier={}, allow_all=True):
        """
        Update records which fulfill a condition.

        Parameters
        ----------
        db: Connection
            DB connection.
        values: {str: object} | model
            Columns and values to update.
        condition: Q.C | Marker -> Q.C
            Condition or a function creating a condition with a marker.
        qualifier: {str: str -> str}
            A mapping from column name to a function converting holder marker into another SQL expression.
        allow_all: bool
            Empty condition raises an exception if this is `False`.

        Returns
        -------
        object
            An object returned by `execute()` of DB-API 2.0 module.
        """
        value_dict = model_values(cls, values, excludes_pk=True)
        check_columns(cls, value_dict)
        cols, vals = list(value_dict.keys()), list(value_dict.values())
        qualifier = key_to_index(qualifier, cols)

        def set_col(acc, icv):
            i, (c, v) = icv
            if isinstance(v, Expression):
                clause = f"{c} = {qualifier.get(i, lambda x:x)(v.expression)}"
                params = v.params
            else:
                clause = f"{c} = {qualifier.get(i, lambda x:x)('$_')}"
                params = [v]
            acc[0].append(clause)
            acc[1].extend(params)
            return acc

        setters, params = reduce(set_col, enumerate(zip(cols, vals)), ([], []))

        wc, wp = where(condition)
        if wc == "" and not allow_all:
            raise ValueError("Update query to update all records is not allowed.")

        c = db.stmt().execute(f"UPDATE {cls.name} SET {', '.join(setters)}{_spacer(wc)}", *(params + wp))

        return getattr(c, "rowcount", None)

    @classmethod
    def delete(cls, db, pks):
        """
        Delete a record by primary key(s).

        Parameters
        ----------
        db: Connection
            DB connection.
        pks: object | {str: object}
            A primary key or a mapping from column name to a value of primary keys.

        Returns
        -------
        object
            An object returned by `execute()` of DB-API 2.0 module.
        """
        cols, vals = parse_pks(cls, pks)
        return cls.delete_where(db, Conditional.all([Q.eq(**{c: v}) for c, v in zip(cols, vals)])) == 1

    @classmethod
    def delete_where(cls, db, condition, allow_all=True):
        """
        Delete records which fulfill a condition.

        Parameters
        ----------
        db: Connection
            DB connection.
        gen_condition: Q.C | Marker -> Q.C
            Condition or a function creating a condition with a marker.
        allow_all: bool
            Empty condition raises an exception if this is `False`.

        Returns
        -------
        object
            An object returned by `execute()` of DB-API 2.0 module.
        """
        wc, wp = where(condition)
        if wc == "" and not allow_all:
            raise ValueError("Delete query to delete all records is not allowed.")

        c = db.stmt().execute(f"DELETE FROM {cls.name}{_spacer(wc)}", *wp)

        return getattr(c, "rowcount", None)

    @classmethod
    def last_sequences(cls, db, num):
        """
        Returns latest auto generated numbers in this table.

        Parameters
        ----------
        db: Connection
            DB connection.
        num: int
            The number of records inserted by the latest insert query.

        Returns
        -------
        [(Column, int)]
            A list of pairs of column and the generated number.
        """
        return []


def _spacer(s):
    return (" " + str(s)) if s else ""